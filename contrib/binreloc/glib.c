static gchar *exe = NULL;


/*
 * The BinReloc functions should only be called once - during startup.
 * Store the results in global variables, which you use throughout the
 * program's life cycle.
 * You are free to set those global variables to static hard-coded paths.
 * if BinReloc fails for whatever reason.
 */


/** Initialize the BinReloc library.
 *
 * This function must be called before using any other BinReloc functions.
 * It attempts to locate the application's filename.
 *
 * @param error  If BinReloc failed to initialize, then the error report will
 *               be stored in this variable. Set to NULL if you don't want an
 *               error report.
 *
 * @returns TRUE on success, FALSE if BinReloc failed to initialize.
 */
gboolean
gbr_init (GError **error)
{
	gchar *file, *error_message;
	GbrFindExeError errcode;

	/* Locate the application's filename. */
	file = br_find_exe (&errcode);
	if (file != NULL) {
		/* Success! */
		exe = file;
		return TRUE;
	}


	/* Failed :-( */
	switch (errcode) {
	case GBR_FIND_EXE_NOMEM:
		error_message = "Cannot allocate memory.";
		break;
	case GBR_FIND_EXE_OPEN_MAPS:
		error_message = "Unable to open /proc/self/maps for reading.";
		break;
	case GBR_FIND_EXE_READ_MAPS:
		error_message = "Unable to read from /proc/self/maps.";
		break;
	case GBR_FIND_EXE_INVALID_MAPS:
		error_message = "The file format of /proc/self/maps is invalid.";
		break;
	case GBR_FIND_EXE_DISABLED:
		error_message = "Binary relocation support is disabled.";
	default:
		error_message = "Unknown error.";
		break;
	};
	g_set_error (error, g_quark_from_static_string ("GBinReloc"),
		     errcode, "%s", error_message);
	return FALSE;
}


/** Find the absolute filename of the current process's executable.
 *
 * @returns A filename (which must be freed when no longer necessary),
 *          or NULL on error.
 */
gchar *
gbr_find_exe ()
{
	g_return_val_if_fail (exe != NULL, NULL);
	return g_strdup (exe);
}


/** Locate the prefix in which the current application is installed.
 *
 * The prefix is generated by the following pseudo-code evaluation:
 * \code
 * dirname(dirname(exename))
 * \encode
 *
 * @param default_prefix  A default prefix which will used as fallback.
 * @return A string containing the prefix, which must be freed when no
 *         longer necessary. If BinReloc is not initialized, or if
 *         gbr_init() failed, then a copy of default_prefix will be returned.
 *         If default_prefix is not given, then NULL will be returned.
 */
gchar *
gbr_find_prefix (const gchar *default_prefix)
{
	gchar *dir1, *dir2;

	if (exe == NULL) {
		/* BinReloc not initialized. */
		if (default_prefix != NULL)
			return g_strdup (default_prefix);
		else
			return NULL;
	}

	dir1 = g_path_get_dirname (exe);
	dir2 = g_path_get_dirname (dir1);
	g_free (dir1);
	return dir2;
}


/** Locate the application's data folder.
 *
 * The path is generated by the following pseudo-code evaluation:
 * \code
 * prefix + "/share"
 * \endcode
 *
 * @param default_data_dir  A default path which will used as fallback.
 * @return A string containing the data folder's path, which must be freed when
 *         no longer necessary. If BinReloc is not initialized, or if
 *         gbr_init() failed, then a copy of default_data_dir will be returned.
 *         If default_data_dir is not given, then NULL will be returned.
 */
gchar *
gbr_find_data_dir (const gchar *default_data_dir)
{
	gchar *prefix, *dir;

	prefix = gbr_find_prefix (NULL);
	if (prefix == NULL) {
		/* BinReloc not initialized. */
		if (default_data_dir != NULL)
			return g_strdup (default_data_dir);
		else
			return NULL;
	}

	dir = g_build_filename (prefix, "share", NULL);
	g_free (prefix);
	return dir;
}


/** Locate the application's localization folder.
 *
 * The path is generated by the following pseudo-code evaluation:
 * \code
 * prefix + "/share/locale"
 * \endcode
 *
 * @param default_locale_dir  A default path which will used as fallback.
 * @return A string containing the localization folder's path, which must be freed when
 *         no longer necessary. If BinReloc is not initialized, or if
 *         gbr_init() failed, then a copy of default_locale_dir will be returned.
 *         If default_locale_dir is not given, then NULL will be returned.
 */
gchar *
gbr_find_locale_dir (const gchar *default_locale_dir)
{
	gchar *data_dir, *dir;

	data_dir = gbr_find_data_dir (NULL);
	if (data_dir == NULL) {
		/* BinReloc not initialized. */
		if (default_locale_dir != NULL)
			return g_strdup (default_locale_dir);
		else
			return NULL;
	}

	dir = g_build_filename (data_dir, "locale", NULL);
	g_free (data_dir);
	return dir;
}


gchar *
gbr_find_config_file (const gchar *base_name, const gchar *default_config_dir)
{
	const gchar *xdg_config_home;
	const gchar *xdg_config_dirs;
	gchar *dir, *found = NULL;
	GList *search_paths = NULL;
	GList *tmp;

	g_return_val_if_fail (base_name != NULL, NULL);

	/*
	 * Generate a list of search paths. Look in each directory
	 * for the file.
	 */

	/* Add /etc to search path. */
	search_paths = g_list_prepend (search_paths, g_strdup ("/etc"));


	/* Add XDG_CONFIG_DIRS to search path. */
	xdg_config_dirs = g_getenv ("XDG_CONFIG_DIRS");
	if (xdg_config_dirs != NULL && *xdg_config_dirs != '\0') {
		gchar **dirs, **tmp;

		dirs = g_strsplit (xdg_config_dirs, ":", -1);
		for (tmp = dirs; *tmp != NULL; tmp++)
			g_list_prepend (search_paths, g_strdup (*tmp));
		g_strfreev (dirs);

	} else
		/* $XDG_CONFIG_DIRS not set or empty; fallback to default
		   as specified in the specification. */
		search_paths = g_list_append (search_paths, g_strdup ("/etc/xdg"));


	/* Add XDG_CONFIG_HOME to search path. */
	xdg_config_home = g_getenv ("XDG_CONFIG_HOME");
	if (xdg_config_home != NULL && *xdg_config_home != '\0')
		dir = g_strdup (xdg_config_home);

	else {
		/* $XDG_CONFIG_HOME not set or empty; fallback to default
		   as specified in the specification. */
		const gchar *home;

		home = g_getenv ("HOME");
		if (home == NULL || *home == '\0')
			home = g_get_home_dir ();

		dir = g_build_filename (home, ".config");
	}

	search_paths = g_list_prepend (search_paths, dir);


	/* Add default config directory. */
	if (default_config_dir != NULL)
		search_paths = g_list_prepend (search_paths, g_strdup (default_config_dir));

	/* TODO: add $prefix/etc ? */


	/* Finally, search the file. */
	for (tmp = g_list_first (search_paths); tmp != NULL; tmp = tmp->next) {
		gchar *path;

		path = g_build_filename ((gchar *) tmp->data, base_name, NULL);
		if (g_file_test (path, G_FILE_TEST_EXISTS)) {
			found = path;
			break;
		} else
			g_free (path);
	}

	/* Free strings. */
	for (tmp = g_list_first (search_paths); tmp != NULL; tmp = tmp->next)
		g_free (tmp->data);

	return found;
}
